<!-- TOC -->

- [一 面向对象](#%E4%B8%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)
    - [一.1 引子-人狗大战](#%E4%B8%801-%E5%BC%95%E5%AD%90-%E4%BA%BA%E7%8B%97%E5%A4%A7%E6%88%98)
        - [一.1.1代码](#%E4%B8%8011%E4%BB%A3%E7%A0%81)
        - [一.1.2 代码思考](#%E4%B8%8012-%E4%BB%A3%E7%A0%81%E6%80%9D%E8%80%83)
    - [一.2 类](#%E4%B8%802-%E7%B1%BB)
        - [一.2.1 类之间的关系](#%E4%B8%8021-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB)
        - [一.2.2 类的继承](#%E4%B8%8022-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF)
        - [一.2.3 类的多态](#%E4%B8%8023-%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81)
        - [一.2.4 类的封装](#%E4%B8%8024-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85)

<!-- /TOC -->


# 一 面向对象
## 一.1 引子-人狗大战
### 一.1.1代码

<details>
<summary><span style="color: #dae634;">代码（点击打开）</span></summary>

```python
# 定义狗的攻击值映射
attack_vals = {
    "土狗": 20,
    "狼狗": 30,
    "藏獒": 40
}

def dog(name,d_type): # 狗打人
    data = {
        "name":name,
        "d_type":d_type,
        "life_val":100,
    }
    if d_type in attack_vals:
        data["attack_val"] = attack_vals[d_type]
    else:
        data["attack_val"] = 15

    def dog_bite(person_obj):
        person_obj["life_val"] -= data["attack_val"]  # 执行咬人动作
        print(f"狗{data['name']}咬了人{person_obj['name']}一口，人掉血{data['attack_val']}，还有血量{person_obj['life_val']}...")
 
    data["bite"] = dog_bite # 绑定方法到字典，外部可调用
    return data


def person(name, p_type="普通人"):  # 人打狗
    data = {
        "name": name,
        "p_type": p_type,
        "life_val": 100,  # 初始生命值和狗保持一致
    }
    # 不同职业的人对应不同攻击值
    person_attack_map = {
        "奶妈": 18,
        "决斗位": 30,
        "信息位": 25
    }
    if p_type in person_attack_map:
        data["attack_val"] = person_attack_map[p_type]
    else:
        data["attack_val"] = 18  # 默认攻击值

    def person_attack(dog_obj):
        # 人攻击狗的逻辑
        dog_obj["life_val"] -= data["attack_val"]
        print(f"人{data['name']}打了狗{dog_obj['name']}一拳，狗掉血{data['attack_val']}，还有血量{dog_obj['life_val']}...")

    data["attack"] = person_attack  # 绑定攻击方法到字典
    return data

# --- 测试：人狗大战演示 ---
if __name__ == "__main__":
    # 创建角色
    dog1 = dog("旺财", "土狗")
    per1 = person("贤者", "奶妈")

    # 触发战斗
    dog1["bite"](贤者)  # 狗先咬人
    per1["attack"](旺财)  # 人反击狗

    # 查看战后状态
    print(f"\n战后状态：")
    print(f"小明剩余血量：{小明['life_val']}")
    print(f"旺财剩余血量：{旺财['life_val']}")
```  
</details>

### 一.1.2 代码思考
 `data["attack"] = person_attack`  
这样做是为了将狗/人的行为分别绑定到狗/人的字典中  
每个角色专属调用  
不会出现你是个人却调用狗的方法  
其实也可以有别的方法  
比如：  
* 用类class去封装属性和方法，一个类定义人，一个定义狗，再进行额外校验，在狗的类中确保传入的是人的实例,例子如下：  

<details>
<summary><span style="color: #dae634;">代码（点击打开）</span></summary>

```python
class Dog:
    # 狗的类：只定义狗的专属属性和方法
    def __init__(self, name, d_type):
        self.name = name
        self.d_type = d_type
        self.life_val = 100
        self.attack_val = {"土狗":20, "狼狗":30, "藏獒":40}.get(d_type, 15)
    
    # 狗的专属方法：只能咬“人”
    def bite(self, person):
        # 额外校验：确保传入的是Person类实例（双重保险）
        if not isinstance(person, Person):
            raise TypeError("狗只能咬【人】，不能咬其他类型！")
        person.life_val -= self.attack_val
        print(f"狗[{self.name}]咬了人[{person.name}]，人剩余血量：{person.life_val}")
```
</details>

* 物理隔离也可以，人.py中定义人，狗.py中定义狗，然后通过import导入再调用  


## 一.2 类
* **先写公有 ， 再写私有， 再写外部调用函数**

**Q: 类，对象，实例，实例化的关系**
A：类是对象的模板，对象是类的实例，实例化是创建对象的过程  

**Q: 类属性和实例属性的区别**
A：类属性是类的属性，实例属性是实例的属性  
   类属性是所有实例共享的，实例属性是每个实例独有的
   通俗说就是在init外的属性是类属性，在init内的属性是实例属性


### 一.2.1 类之间的关系

| 关系类型 | 核心特点（通俗版） | 代码表现 | 瓦例子 |
|----------|--------------------|----------|------------------------|
| 依赖关系 | **临时借用**：A对象的某个方法中，临时使用B对象，方法执行结束后关系断开，无长期绑定 | A的方法参数/内部临时使用B对象，A不持有B的实例属性 | 盖可使用皮蛋侦查A点角落，侦查完成后皮蛋自动消失，仅在侦查动作期间存在依赖关系 |
| 关联关系 | **长期认识**：A与B互相持有对方引用，长期保持联系，彼此独立但存在绑定 | A拥有B类型的实例属性，B也拥有A类型的实例属性，双向绑定 | 盖可与皮蛋是专属绑定关系，整场比赛中盖可都能指挥自己的皮蛋，皮蛋也只响应该盖可的指令，双方长期关联 |
| 组合关系 | **生死与共**：A是整体，B是A的组成部分；B由A创建，A销毁则B也随之销毁，无法脱离A独立存在 | B对象在A的`__init__`方法中创建，B仅属于当前A，不能被其他对象复用 | 盖可召唤皮蛋（由盖可生成），若盖可被敌方淘汰（退出游戏），其所有伙伴（皮蛋/丢丢/嗨宝/鲨鲨）会立即消失，无法脱离盖可独立存在 |



背景：  
每个盖可（红队 / 蓝队）都有专属的 4 个生物伙伴  
* 皮蛋：侦查敌人 + 震荡冲击（Q 技能）
* 丢丢：扔闪光弹致盲敌人（E 技能）
* 嗨宝：释放毒雾并爆炸逼退敌人（C 技能）
* 鲨鲨：拘束敌人方便队友收割（X 大招）

操作：  
每个生物伙伴只认自己的专属盖可  
盖可单独只会单个伙伴释放技能

思考：  
**Q1.怎样让伙伴绑定专属盖可？**  
A1：定义伙伴类的时候，奖盖可作为参数传入绑定到伙伴的实例中  

**Q2.怎么保证只有专属盖可才能指挥伙伴？**    
A2: 在执行技能前检查指挥者是不是绑定的盖可对象  

**Q3.盖可如何拥有自己的四个伙伴？**  
A3:初始化的时候，创建四个伙伴实例，都传进self中

<details>
<summary><span style="color: #dae634;">代码（点击打开）</span></summary>

```python
class companion:
    def __init__ (self,name,skill,master):
        self.name=name
        self.skill=skill
        # 【关联关系】：伙伴持有盖可（Master）对象的引用，长期绑定
        self.master=master

    def doskill(self,master):
        if master==self.master:
            print(f"{self.name}接收到{master}的指令，使用了{self.skill}技能！")
        else:
            print(f"你不是我的主人，无法使用该技能！")

class master: 
    def __init__(self,name,team):
        self.name=name
        self.team=team

        # 【组合关系】：伙伴由盖可创建，是盖可的一部分，盖可销毁则伙伴也销毁
        self.pidan=companion("皮蛋","探测",self.name)
        self.guikai=companion("丢丢","致盲",self.name)
        self.hiabao=companion("嗨宝","放毒",self.name)
        self.shasha=companion("鲨鲨","约束",self.name)
    
    def command(self,companion):
        print(f"{self.name}向{companion.name}发出指令，使用{companion.skill}技能")
        # 【依赖关系】：盖可临时调用伙伴的do_skill方法，仅在该方法执行时依赖伙伴对象
        companion.doskill(self.name)

#实例化

#创建两个队的盖可
person_red=master("盖可red","红队")
person_blue=master("盖可blue","蓝队")

print("--"*30)

#盖可red发出指令

person_red.command(person_red.guikai)
print("--"*30)

#盖可blue发出指令
person_blue.command(person_blue.pidan)
print("--"*30)

#验证盖可blue无法指挥盖可red的伙伴
person_blue.command(person_red.pidan)

```
</details>



### 一.2.2 类的继承

**继承**：子类继承父类，子类拥有父类的属性和方法，子类可以扩展父类的方法，也可以重写父类的方法

**继承的好处**：  
1. 代码复用  
2. 提高代码可维护性  
3. 提高代码可扩展性  

* 多继承的话采用c3算法，如果你觉得这个算法的继承顺序不符合你的逻辑  
  那你就在子类里面单独去调用你需要的那个父类的方法即可

<details>
<summary><span style="color: #dae634;">代码（点击打开）</span></summary>

```python
class people:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def smile(self):
        print(f"{self.name} is smiling.")

    def sleep(self):
        print(f"{self.name} is sleeping.")

class gaike(people):
    def __init__(self, name, age, X_skill):
        super().__init__(name, age)  # 调用父类的构造函数
        self.X_skill = X_skill

    def X(self):
        print(f"{self.name} is using X skill.")

class naima(Animal):
    def __init__(self, name, age, Q_skill):
        super().__init__(name, age)  # 调用父类的构造函数
        self.Q_skill = Q_skill

    def Q(self):
        print(f"{self.name} is using Q skill.")

# 创建对象
gaike = gaike("盖可", 18, "大招")
naima = naima("奶妈", 18, "减速")

# 调用父类的方法
gaike.smile()
gaike.sleep()

# 调用子类的方法
gaike.X()

```
</details>

### 一.2.3 类的多态

**多态**：同一个方法，不同的对象有不同的实现，同一个接口，不同的对象有不同的实现

**多态的好处**：  
1. 代码复用  
2. 提高代码可维护性  
3. 提高代码可扩展性  

<details>
<summary><span style="color: #dae634;">代码（点击打开）</span></summary>

```python
class people:
    def __init__(self, name):
        self.name = name

    def useskill(self):
        pass

class gaike(people):
    def useskill(self):
        print(f"{self.name} is useskill.")

class naima(people):
    def useskill(self):
        print(f"{self.name} is useskill.")

def people_use(person):
    animal.useskill()

gaike = gaike("盖可")
naima = naima("奶妈")

people_use(gaike)
people_use(naima)
```
</details>



### 一.2.4 类的封装

**封装**：将对象的属性和方法封装起来，对外隐藏实现细节，只暴露出必要的接口

**封装的好处**：
1. 隐藏实现细节，提高代码可维护性  
2. 控制访问权限，提高代码安全性  
3. 提高代码可复用性  

<details>
<summary><span style="color: #dae634;">代码（点击打开）</span></summary>

```python
class BLOOD:
    def __init__(self, blood):
        self._blood=blood # 变量私有，前面加下划线“-”

    def add_blood(self):
        return self._blood+10

    def set_blood(self,blood):
        self._blood=blood

    #函数私有
    def _reduce_blood(self):
        return self._blood-10

# 创建对象

dog=BLOOD(100)

print(dog.add_blood())

# dog._reduce_blood()  # 报错，不能直接调用私有方法

# dog._blood=200  # 报错，不能直接访问私有变量

```
</details>



